---
title: "Calculating disease severity by adjusting for delays between onset and outcome during an outbreak"
output:
  html_document: 
    toc: true
    theme: cosmo
editor_options:
  chunk_output_type: console
subttitle: Estimating the number of cases that likely have a known outcome at each
  time, for a time series of cases and deaths
bibliography: resources/library.bib
csl: resources/bmj.csl
vignette: "# %\\VignetteIndexEntry{datadelay Case Study 1}\n%\\VignetteEncoding{UTF-8}\n%\\VignetteEngine{knitr::rmarkdown}\n"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  collapse=TRUE,
  echo=TRUE,
  comment = "#>",
  eval=TRUE
)
```

# Overview
This vignette outlines how to use `datadelay` to calculate disease severity during an ongoing outbreak. For example, we may wish to estimate values such as the
*case fatality risk (CFR)* or *hospitalisation fatality risk (HFR)*. We can do using a method that jointly analyses a time series of cases and disease outcomes with a
delay distribution. The methods used here are based on those in Nishiura et al. (2009)^[@nishiura2009early]^.

This vignette demonstrates how to implement the core functions within `datadelay`. Specifically, we will cover

1. Why 'naive' estimates of CFR or HFR generated during an ongoing outbreak (i.e. ratio of total cases to date and total outcomes to date) require adjusting for delays from onset-to-outcome.
2. Generate estimates over time for the number of cases that so far have a known outcome
symptom onset
3. Define an unbiased estimator to estimate the CFR or HFR from Nishiura et al (2009)^[@nishiura2009early]^
4. Numerically implement the unbiased estimator numerically using maximum likelihood estimation to arrive at central estimates of the CFR or 
HFR, along with a confidence interval.

# Setup: installation and requirements

`datadelay` can be installed from Github, using the `devtools` package, with the following command:

```{r message = FALSE, warning = FALSE, eval = FALSE}
# installs the datadelay package from Github, as recommended on their repository:
# https://github.com/epiverse-trace/datadelay
if(!require("devtools")) install.packages("devtools")
devtools::install_github("epiverse-trace/datadelay")
```

Additionally, there are two more packages required for this analysis. The `epiparameter` package is the source of the delay distributions used 
and the `covidregionaldata` package is the source of the case and death time-series used in the second example in this vignette. We install
`epiparameter` using the following command:

```{r, message = FALSE, warning = FALSE, eval = FALSE}
# installs the epiparameter package from Github, as recommended on their repository:
# https://github.com/epiverse-trace/epiparameter
if(!require("remotes")) install.packages("remotes")
remotes::install_github("epiverse-trace/epiparameter")
```

We install `covidregionaldata` using the following command:

```{r, message = FALSE, warning = FALSE, eval = FALSE}
# installs the stable version of covidregionaldata package from r-universe, as recommended on 
# their repository: 
# https://github.com/epiforecasts/covidregionaldata
install.packages("covidregionaldata", repos = "https://epiforecasts.r-universe.dev")
```

Now we load the three packages we need using the following commands:

```{r, message = FALSE, warning=FALSE, eval = TRUE}
library(datadelay)
library(epiparameter)
library(covidregionaldata)
```

# Motivation

Key epidemiological quantities estimated in real-time often suffer from biases. In particular, dividing deaths-to-date by cases-to-date 
or hospitalisations-to-date leads to biased estimates of the CFR or HFR (respectively). This is because this calculation does not account 
for delays from confirmation of a case or hospitalisation to death. 

If we had perfectly synchronised case and death incidence data, the basic versions of the CFR and HFR — defined as either the ratio of the 
total number of deaths and the total number of cases or hospitalisations (respectively) — would be accurate. These basic estimates are referred 
to as naive estimators. However, due to delays between onset or hospitalisation and death for all known diseases, this synchronisation is
never true.

For example, suppose 10 people start showing symptoms of a specific disease on a given day and the end of that day all remain alive. Suppose
that for the next 5 days, the numbers of new cases continue to rise until they reach 100 new cases on day 5. However, suppose that by day 5, 
all infected individuals remain alive. The naive estimate of the CFR would be zero calculated at the end of the first 5 days would be zero,
because there would have been zero deaths in total. Even after deaths begin to occur, this lag between the ascertainment of a case or 
hospitalisation and outcome leads to a consistently biased estimate. Hence, adjusting for such delays using an appropriate delay distribution 
is essential for accurate estimates of severity.

# Data required

This method require three sets of data:

* A time-series of cases;
* A time-series of deaths;
* A delay distribution, describing the probability an individual will die $t$ days after they were initially exposed. Such distributions come from the literature, where studies have typically fit distributions to data describing the process. 

In practice, the time-series of cases and deaths will already be together, given that they usually originate from sources that will have typically collated them into a single data file.

# Example with data from the 1976 Ebola outbreak in the Democratic Republic of the Congo

We use data from the 1976 Ebola outbreak. First of all, we plot the data from the entire outbreak. Then we subset 
the data isolating about half of it, to emulate estimating severity during an ongoing outbreak.

## Plotting the raw data

First of all, we plot the raw data

```{r message = FALSE, warning = FALSE, eval = TRUE, fig.cap = "\\label{fig:raw_data_ebola} **Figure 1:** Incidence of cases and deaths over time, taken from the 1976 Ebola outbreak in the Democratic Republic of the Congo. Data retrieved from within the *datadelay* package"}
data("ebola1976")
plot_raw_data(ebola1976, together = TRUE)
```

The argument `together = FALSE` of the `plot_raw_data()` function plots the case and death times series on a 
single figure, rather than two separate figures. This is useful if the raw values are similar and they can 
effectively share a scale. Otherwise, using the `together = TRUE` plot them on separate figures. The default 
argument is `together = TRUE`.

We will focus on the roughly the first half of this dataset. We do so by subsetting the data so that we only include
days before the 30th September 1976, using the following command:

```{r, message = FALSE, warning = FALSE, eval = TRUE}
df_ebola_subset <- subset(ebola1976, date <= "1976-09-30")
```

After subsetting, the dataset we focus on for the rest of this example looks like this:

```{r message = FALSE, warning = FALSE, eval = TRUE, fig.cap = "\\label{fig:raw_data_ebola} **Figure 2:** A subset of the 1976 Ebola outbreak dataset, emulating a timepoint during an ongoing outbreak."}
plot_raw_data(df_ebola_subset, together = TRUE)
```

## The delay distribution

For this example, given that we are using case data and detection of a case is well-approximated by symptom onset, we use the distribution 
describing the delay between onset-to-death. As such, we retrieve such a distribution from the literature 
(reported [here](https://doi.org/10.1016/S0140-6736(18)31387-4)), using the `epidist_db()` function from the `epiparameter` package with 
the following command:

```{r message=FALSE, warning=FALSE, eval=TRUE}
onset_to_death_ebola <- epiparameter::epidist_db(
  disease = "Ebola Virus Disease", 
  epi_dist = "onset_to_death",
  author = "Barry_etal")
```

To visualise this distribution, we evaluate it between 0 and 30 days, and plot the results over time:

```{r, message = FALSE, warning = FALSE, eval = TRUE, fig.cap = "\\label{fig:delay_dist_ebola} **Figure 3: Example plot of the appropriate delay distribution for the 1976 Ebola dataset.** We plot the onset-to-death distribution we use throughout this example for Ebola Virus Disease (EVD), reported in https://doi.org/10.1016/S0140-6736(18)31387-4."}
plot_epiparameter_distribution(onset_to_death_ebola, by = 0.1)
```

## Estimating the number and proportion of cases or hostpitalisations which have a known outcome over time

The function `calculate_known_outcomes()` from the `datadelay` package estimates the number of cases which have a known outcome over time. 
The method used within this function follows Nishiura et al.^[@nishiura2009early]^. The function calculates a quantity $u_t$ for each day within 
the input data, which represents the proportion of cases with a known outcome, on day $t$. Following Nishiura et al., $u_t$ is calculated 
in the following way:

\begin{equation}
  u_t = \frac{\sum_{i = 0}^t \sum_{j = 0}^\infty c_i f_{j - i}}{\sum_{i = 0} c_i}
\end{equation}

It requires a `data.frame` of input data --- typically case and death time series data --- and a delay distribution. The delay distribution we use here comes from the ```epiparameter``` package, as described in the previous subsection.

```{r message=FALSE, warning=FALSE, eval=TRUE, fig.cap = "\\label{fig:known_outcomes_ebola} **Figure 3:** The same case and death time series for the 1976 Ebola outbreak in D.R.C., with estimated known outcomes included."}
df_known_outcomes_ebola <- known_outcomes(
  df_in = df_ebola_subset,
  epi_dist = onset_to_death_ebola)
  
plot_known_outcomes(df_known_outcomes_ebola)
```

## Estimating the naive and corrected CFR

Once we calculate the proportion of cases with known outcomes, we apply the proportion to the number of cases to correct for the delay 
between onset-to-death. We do so by using the function `static_cfr()` from the `datadelay` package. This function estimates the proportion of
known outcomes over time, and uses the estimate to correct the naive CFR estimate, if the argument `correct_for_delays = TRUE` is set. Otherwise, 
it calculates the naive CFR. We run this function using the following commands:

```{r message = FALSE, warning = FALSE, eval = TRUE}
# calculating the naive CFR
dt_ncfr_static_ebola <- static_cfr(
  df_ebola_subset,
  correct_for_delays = FALSE) |> 
  format_cfr_neatly(type = "Naive")

# calculating the corrected CFR
dt_ccfr_static_ebola <- static_cfr(
  df_ebola_subset,
  correct_for_delays = TRUE,
  epi_dist = onset_to_death_ebola) |>
  format_cfr_neatly(type = "Corrected")

# putting the two results together
dt_static_clean_ebola <- rbind(dt_ncfr_static_ebola, dt_ccfr_static_ebola)
```

Once we have calculated both the naive and corrected CFR values, we put them together and make a table, using the `kable()` function 
from the `knitr` package, using the following command:

```{r message=FALSE, warning=FALSE, eval=TRUE}
knitr::kable(dt_static_clean_ebola,
             align = "c",
             col.names = c("CFR estimate", "Type")) |> 
  kableExtra::kable_styling(full_width = FALSE)
```

# Example with data from the ongoing COVID-19 pandemic in the U.K.

We now perform a similar analysis with all of the same steps, with data taken from the ongoing COVID-19 epidemic in the U.K. For brevity, we 
describe the steps without methodological explanations throughout this example.

## Plotting the raw data

First of all, we subset the data so that we focus on just the first year of the COVID-19 outbreak in the U.K. We do so, 
as the CFR changed dramatically as a result of the vaccine campaign. The static severity calculations we are performing 
in this vignette are not able to deal with changes in severity over time. We download the data --- using
the `covidregionaldata` package ---  and subset it with the following commands:

```{r, message = FALSE, warning = FALSE, eval = TRUE}
df_covid_uk <- covidregionaldata::get_national_data(
  countries = "united kingdom", source = "who", verbose = FALSE) |>
  dplyr::rename(cases = cases_new, deaths = deaths_new)

df_covid_uk_subset <- subset(df_covid_uk, date > "2020-07-01" & date <= "2020-11-01")
```

Then, we plot the subsetted data with following command:

```{r, message = FALSE, warning = FALSE, eval = TRUE, fig.cap = "\\label{fig:raw_data_covid} **Figure 4:** Incidence of cases and deaths over time for the ongoing COVID-19 outbreak in the U.K."}
plot_raw_data(df_covid_uk_subset, together = FALSE)
```

## The delay distribution

We again retrieve the appropriate distribution (reported [here](https://doi.org/10.3390/jcm9020538)), using the `epidist_db()` function from the `epiparameter` package, using the following command:

```{r message=FALSE, warning=FALSE, eval=TRUE}
onset_to_death_covid <- epiparameter::epidist_db(
  disease = "COVID-19",
  epi_dist = "onset_to_death",
  author = "Linton_etal")
```

To visualise this distribution, we evaluate it between 0 and 30 days, and plot the results over time. We do so using the following command:

```{r message=FALSE, warning=FALSE, eval=TRUE, fig.cap = "\\label{fig:delay_dist_covid} **Figure 5: Example plot of the appropriate delay distribution for the COVID-19 epidemic in the U.K.** We plot the onset-to-death distribution we use throughout this example for COVID-19, reported in https://doi.org/10.3390/jcm9020538."}
plot_epiparameter_distribution(onset_to_death_covid, by = 0.1)
```

## Estimating the number and proportion of cases or hostpitalisations which have a known outcome over time

We use the same method and implementation as in the Ebola example to calculate the number of known outcomes over time, using the following command:

```{r message=FALSE, warning=FALSE, eval=TRUE, fig.cap = "\\label{fig:known_outcomes_covid} **Figure 6:** The same case and death time series for the ongoing COVID-19 epidemic in the U.K., with estimated known outcomes included."}
df_known_outcomes_covid <- known_outcomes(
  df_in = df_covid_uk_subset,
  epi_dist = onset_to_death_covid)
  
plot_known_outcomes(df_known_outcomes_covid, together = FALSE)
```

## Estimating the naive and corrected CFR

Using the same functions as the Ebola example, we calculate the naive and corrected CFRs for the COVID-19 epidemic in the U.K:

```{r message = FALSE, warning = FALSE, eval = TRUE}
# calculating the naive CFR
dt_ncfr_static_covid <- static_cfr(
  df_covid_uk_subset,
  correct_for_delays = FALSE) |> 
  format_cfr_neatly(type = "Naive")

# calculating the corrected CFR
dt_ccfr_static_covid <- static_cfr(
  df_covid_uk_subset,
  correct_for_delays = TRUE,
  epi_dist = onset_to_death_covid) |>
  format_cfr_neatly(type = "Corrected")

# putting the two results together
dt_static_clean_covid <- rbind(dt_ncfr_static_covid, dt_ccfr_static_covid)
```

Once we have calculated both the naive and corrected CFR values, we put them together and make a table, using the `kable()` function 
from the `knitr` package, using the following command:

```{r message=FALSE, warning=FALSE, eval=TRUE}
knitr::kable(dt_static_clean_covid,
             align = "c", 
             col.names = c("CFR estimate", "Type")) |> 
  kableExtra::kable_styling(full_width = FALSE)
```
