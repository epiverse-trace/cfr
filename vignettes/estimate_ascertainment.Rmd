---
title: "Estimating the proportion of cases that are ascertained during an outbreak"
output:
  bookdown::html_vignette2:
    fig_caption: yes
    code_folding: show
pkgdown:
  as_is: true
bibliography: resources/library.json
link-citations: true
vignette: >
  %\VignetteIndexEntry{Estimating the proportion of cases that are ascertained during an outbreak}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  dpi = 300,
  fig.width = 5, fig.height = 3
)
```

Cases, infections or hospitalisations and deaths might be under-ascertained during an outbreak of an infectious disease for reasons including testing capacity, criteria not being sufficient to identify all infections, or symptom-based testing rather than random sampling, or changes in case definition over time.

::: {.alert .alert-warning}
New to calculating disease severity using _cfr_? You might want to see the ["Get started" vignette first](cfr.html).
:::

::: {.alert .alert-primary}
## Use case {-}

We wish to estimate one of the typical severity quantities used in epidemiology -- the *case fatality risk (CFR)*, *infection hospitality risk (IFR)* or  *hospitalisation fatality risk (HFR)* -- using a method that uses a time series of cases, infections or hospitalisations (respectively) and deaths, _while correcting for the delay in reporting the outcomes of cases_.
:::

::: {.alert .alert-secondary}
### What we have {-}

* A time-series of cases, hospitalisations or some other proxy for infections over time;
* A time-series of deaths;
* Data on the distribution of delays, describing the probability an individual will die $t$ days after they were initially infected.

The first two elements are expected be included in a dataframe with the columns "dates", "cases", and "deaths".
:::

This vignette shows how to use the `estimate_ascertainment()` function in _cfr_ to estimate the proportion of cases, infections or hospitalisations ascertained, and consequently, the extent of under-ascertainment or under-reporting.
Note that under-ascertainment may be due to a number of reasons (see above), while under-reporting is due to cases not being reported (such as due to a lack of testing capacity).
Users should take care to use the correct terminology for their specific situation.

We have named the function `estimate_ascertainment()` as we expect that users will be most interested in situations where testing capacity is itself the limiting factor in ascertainment.
This was the case during the Covid-19 pandemic before testing capacity was substantially increased, and is expected to be the case for a future pandemic caused by a novel pathogen.

First load _cfr_ and packages to access and plot data.

```{r, message = FALSE, warning=FALSE, eval = TRUE}
# load {cfr} and data packages
library(cfr)

# packages to wrangle and plot data
library(dplyr)
library(tidyr)
library(purrr)
library(scales)
library(forcats)
library(ggplot2)
```

## Ascertainment for the Covid-19 pandemic in the U.K.

The function `estimate_ascertainment()` from the _cfr_ package estimates the proportion of cases, infections, hospitalisations -- or whichever proxy for infections is provided -- which have been ascertained.

The methods are based on @nishiura2009 to estimate severity, and are extended by combining the resulting severity estimates with an assumed baseline severity estimate.

The proportion of cases, infections or other quantity provided that have been ascertained is given by the ratio of the (assumed) true baseline severity estimate, to the delay-adjusted severity estimate.

The delay-adjusted severity estimates can be calculated using either the `cfr_static()` or the `cfr_time_varying()` functions.
See the vignettes on [estimating a static measure of disease severity](cfr_static_severity.html) and [estimating a time-varying measure of disease severity](cfr_time_varying_severity.html), respectively, for more details on each of these functions.

### Preparing the raw data

First we subset the data so that we focus on just the first few months of the COVID-19 outbreak in the U.K.
During this period test availability changed dramatically as a result of the vaccination campaign.

We load data provided with the _cfr_ package and initially made available using the [_covidregionaldata_ package](https://github.com/epiforecasts/covidregionaldata) [@palmer2021].

We filter for data from the United Kingdom here, while later examples will use more of the data.

```{r}
# get Covid data provided with the package
data("covid_data")

# filter for the U.K
df_covid_uk <- filter(covid_data, country == "United Kingdom")

# view the data format
tail(df_covid_uk)
```

We then subset the data to focus on just the first few months of the outbreak in the United Kingdom, and plot the cases and deaths to explore the data.

```{r}
# the first few months of the pandemic
df_covid_uk_subset <- filter(df_covid_uk, date <= "2020-05-31")
```

```{r fig.cap="Incidence of cases over time for the ongoing COVID-19 outbreak in the U.K.", class.source = 'fold-hide'}
ggplot(df_covid_uk_subset) +
  geom_step(
    aes(
      x = date, y = cases
    ),
    colour = "steelblue"
  ) +
  scale_x_date(
    date_labels = "%b-%Y"
  ) +
  scale_y_continuous(
    labels = comma
  ) +
  labs(
    x = "Date", y = "Cases"
  ) +
  coord_cartesian(
    expand = FALSE
  ) +
  theme_classic() +
  theme(legend.position = "top")
```

```{r fig.cap="Incidence of deaths over time for the ongoing COVID-19 outbreak in the U.K.", class.source = 'fold-hide'}
ggplot(df_covid_uk_subset) +
  geom_step(
    aes(
      x = date, y = deaths
    ),
    colour = "brown"
  ) +
  scale_x_date(
    date_labels = "%b-%Y"
  ) +
  scale_y_continuous(
    labels = comma
  ) +
  labs(
    x = "Date", y = "Deaths"
  ) +
  coord_cartesian(
    expand = FALSE
  ) +
  theme_classic() +
  theme(legend.position = "top")
```

### Onset-to-death distribution for Covid-19

We obtain the appropriate distribution reported in @linton2020; this is a log-normal distribution with $\mu$ = 2.577 and $\sigma$ = 0.440.

### Estimating the proportion of cases that have been ascertained

We use the `estimate_ascertainment()` function to calculate the time-varying CFR for the COVID-19 epidemic in the U.K.

The function includes a `type` argument, which determines whether `cfr_static()` or `cfr_time_varying()` is used to estimate the delay-adjusted severity of the disease.

The ascertainment ratio is calculated as the disease severity calculated from the data, divided by the 'known' disease severity; this is expected to be known or assumed from our best knowledge of the pathology of the disease.

This known disease severity is passed to the `severity_baseline` argument in `estimate_ascertainment()`, and forms the numerator in the resulting under-ascertainment calculation.

We assume that the 'true' CFR of Covid-19 is 0.014 (i.e. 1.4%) [@verity2020]. Future plans for this package include ability to incorporate uncertainty in CFR estimates when calculating under-ascertainment.

The other arguments are the same as those found in `cfr_time_varying()`. 

```{r }
df_reporting_static <- estimate_ascertainment(
  data = df_covid_uk_subset,
  delay_density = function(x) dlnorm(x, meanlog = 2.577, sdlog = 0.440),
  type = "static",
  severity_baseline = 0.014
)
```

```{r }
df_reporting_varying <- estimate_ascertainment(
  data = df_covid_uk,
  delay_density = function(x) dlnorm(x, meanlog = 2.577, sdlog = 0.440),
  type = "varying",
  severity_baseline = 0.014,
  burn_in = 7,
  max_date = as.Date("2020-06-30")
)
```

Once we have calculated both severity quantities over time, we visualise the results.

```{r}
# the static reporting estimate
df_reporting_static

# the time-varying reporting estimate
df_reporting_varying
```

## Ascertainment in countries with large early COVID-19 outbreaks

Finally, we estimate ascertainment for all countries with large early outbreaks of Covid-19.

For illustrative purposes, we define a large outbreak as one which resulted in least 100,000 reported COVID-19 deaths between 2020 and 2023, and focus on the period between the start of each outbreak to the 1st of June 2020.

We do so as under-ascertainment of cases and infections was likely to be high in this early period of the pandemic because testing of symptomatic cases was still being scaled up and had not been made widely available in many countries.

We now use the larger dataset `covid_data` made available with the _cfr_ package, and initially made available via the _covidregionaldata_ package [@palmer2021].
We exclude four countries which only provide weekly data (with zeros for dates in between) --- France, Germany, Spain and Ukraine.

We adopt data science tools to iteratively apply the `estimate_ascertainment()` function across data grouped by country.
We refer the user to the book [R for Data Science](https://r4ds.had.co.nz/) for a better explanation of some of the code used here, including from the packages in [the Tidyverse](https://www.tidyverse.org/).

```{r}
# countries with weekly reporting
weekly_reporting <- c("France", "Germany", "Spain", "Ukraine")

# subset for early covid outbreaks
covid_data_early <- filter(
  covid_data, date < "2020-06-01",
  !country %in% weekly_reporting
)

# nest the data
df_reporting <- nest(covid_data_early, .by = country)

# define density function
delay_density <- function(x) dlnorm(x, meanlog = 2.577, sdlog = 0.440)

# calculate the reporting rate in each country using
# map on nested dataframes
df_reporting <- mutate(
  df_reporting,
  reporting = map(
    .x = data, .f = estimate_ascertainment,
    # arguments to function
    delay_density = delay_density, type = "varying",
    severity_baseline = 0.014,
    burn_in = 7
  )
)

# unnest the data
df_reporting <- unnest(df_reporting, cols = "reporting")

# visualise the data
head(df_reporting)
```

Plot the ascertainment for each country.

```{r fig.cap = "Example plot of the ascertainment ratio by country during the early stages of the Covid-19 pandemic.", class.source = 'fold-hide'}
df_reporting %>%
  ggplot() +
  geom_pointrange(
    aes(
      x = fct_reorder(country, ascertainment_mean),
      y = ascertainment_mean,
      ymin = ascertainment_low,
      ymax = ascertainment_high
    )
  ) +
  coord_flip() +
  labs(x = NULL, y = "Ascertainment ratio") +
  theme(legend.position = "none") +
  scale_y_continuous(
    labels = percent, limits = c(0, 1)
  ) +
  theme_classic() +
  theme(legend.position = "top")
```

## References
